<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Chipster Job Manager by CSC-IT-Center-for-Science</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Chipster Job Manager</h1>
        <p>Job execution manager for Chipster</p>

        <p class="view"><a href="https://github.com/CSC-IT-Center-for-Science/chipster-job-manager">View the Project on GitHub <small>CSC-IT-Center-for-Science/chipster-job-manager</small></a></p>


        <ul>
          <li><a href="https://github.com/CSC-IT-Center-for-Science/chipster-job-manager/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/CSC-IT-Center-for-Science/chipster-job-manager/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/CSC-IT-Center-for-Science/chipster-job-manager">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
<h1>
<a id="chipster-jobmanager" class="anchor" href="#chipster-jobmanager" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chipster JobManager</h1>

<p>Chipster JobManager provides capabilities to move the Chipster job management
responsibility away from clients to remote Chipster JobManager service. When
JobManager is in use, the Chipster clients can start a job execution, save the
session state locally and disconnect. Job is then executed on Chipster analysis
servers and managed by the JobManager, which saves the results upon completion
and reschedules the job in case the execution fails.</p>

<h2>Deploying</h2>

<p>
To use JobManager, we need to:
  <ul>
    <li><a href="#activemq">update ActiveMQ configuration</a></li>
    <li><a href="#pip">install the Chipster Job Manager</a></li>
    <li><a href="#config">create configuration</a></li>
    <li><a href="#supervisor">setup runtime environment with Supervisord</a></li>
  </ul>
</p>

<a name="activemq"></a>
<h3>Update ActiveMQ configuration</h3>

<p>To use JobManager with Chipster the message routing configuration must be
changed so that JobManager sits in between the client and analysis servers.</p>

<p>The JobManager uses Stomp, so following entry must be added to
<code>transportConnectors</code> section in <code>chipster/activemq/conf/activemq.xml</code>:</p>

<p>
<code>
&lt;transportConnector name="stomp" uri="stomp://&lt;server_ip&gt;:61613"/&gt;
</code>
</p>

<p>The port number 61613 is the default for stomp protocol. Currently Stomp+SSL transport <a href="https://github.com/nikipore/stompest/issues/3">is not supported</a>.</p>

<p>
Following entry must be added to simpleAuthenticationPlugin.user (change password value):
</p>
<p>
<code>
    &lt;authenticationUser groups="jobmanagers,all" password="changeMe" username="jobmanager"/&gt;
</code>
</p>

<p>
and following entries must be changed / added in authorizationPlugin.map.authorizationMap.authorizationEntries:
</p>

<p>
<code>
    &lt;authorizationEntry admin="all" read="analysers,jobmanagers" topic="comp-admin-topic" write="managers,jobmanagers"/&gt;<br />
    &lt;authorizationEntry admin="all" read="jobmanagers" topic="jobmanager-admin-topic" write="managers"/&gt;<br />
    &lt;authorizationEntry admin="all" read="jobmanagers" topic="jobmanager-topic" write="analysers"/&gt;<br />
    &lt;authorizationEntry admin="all" read="analysers" topic="authorized-managed-request-topic" write="jobmanagers"/&gt;<br />
    &lt;authorizationEntry admin="all" read="jobmanagers" topic="authorised-request-topic" write="authenticators"/&gt;<br />
</code>
</p>

<a name="pip"></a>
<h3>Install Chipster Job Manager</h3>
<p>
While JobManager can be installed just by running Python <code>pip install chipster-job-manager</code> it is encouraged to install the application into a 
Python <a href="https://virtualenv.pypa.io/en/latest/">virtuelenv</a>. If you decide to use virtualenvs create and activate the environment created for JobManager before running the command above.
</p>

<a name="config"></a>
<h3>Configuration</h3>
Create config file config.yaml
<p>
<code>
debug: True<br />
database_dialect: "sqlite"<br />
database_connect_string: "/var/run/db.sqlite"<br />
stomp_endpoint: "tcp://127.0.0.1:61613?startupMaxReconnectAttempts=100,initialReconnectDelay=5000,maxReconnectDelay=5000,maxReconnectAttempts=100"<br />
stomp_login: "loginname"<br />
stomp_password: "password"<br />
</code>
</p>

<a name="supervisor"></a>
<h3>Setup runtime environment with Supervisord</h3>

<p>
JobManager is supposed to be managed by <a href="http://supervisord.org/">Supervisor</a> process control. To install Supervisor in Ubuntu, run <code>aptitude install supervisor</code>.
In supervisor.conf add following section:
</p>
<p>
<code>
[program:jobmanager]
command = path/to/python -m jobmanager.manager /opt/chipster/jobmanager/config.yaml
user = chipster
</code>
</p>

<p>
Check your path/to/python in case you are using virtualenvs. Append <code>--logging path/to/file.log</code> in the command in case you want to redirect the output into a log file.
</p>


<p>To learn more about Chipster refer to: <a href="http://chipster.csc.fi/">http://chipster.csc.fi</a>
</p>

<h1><a id="developing" class="anchor" href="#developing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Developing</h1>
<p>
JobManager manages Job objects, which each represent one job/task submitted by an user to Chipster platform.
JobManager receives authenticated requests from Chipster's authenticator component. Job submissions, state handling and results are communicated with the computing component of the Chipster platform.
Finally the outcome of the computation is reported directly to user's client software.
</p>

<h2>Data model for Jobs</h2>
<h3>DB Schema</h3>
<dl>
    <dt>id</dt><dd>Column(Integer, primary_key=True)</dd>
    <dt>job_id</dt><dd>Column(String(length=40))</dd>
    <dt>session_id</dt><dd>Column(String(length=40))</dd>
    <dt>description</dt><dd>Column(Text)</dd>
    <dt>headers</dt><dd>Column(Text), <span>message headers in job submission request</span></dd>
    <dt>results</dt><dd>Column(Text), <span>message body of job results</span></dd>
    <dt>analysis_id</dt><dd>Column(Text)</dd>
    <dt>reply_to</dt><dd>Column(String(length=255)), topic reported by client where the results are to be sent</dd>
    <dt>state</dt><dd>Column(String(length=32)), Job state, see job <a href="#states">states</a></dd>
    <dt>created</dt><dd>Column(DateTime), timestamp when job was received from client</dd>
    <dt>rescheduled</dt><dd>Column(DateTime), timestamp if job was rescheduled</dd>
    <dt>submitted</dt><dd>Column(DateTime), timestamp when job was submitted to computing component</dd>
    <dt>username</dt><dd>Column(String(255))</dd>
    <dt>finished</dt><dd>Column(DateTime), timestamp when job was finished</dd>
    <dt>seen</dt><dd>Column(DateTime), timestamp of last moment when job was seen running on computing component</dd>
    <dt>retries</dt><dd>Column(Integer, default=0), number of retries used to execute the job</dd>
    <dt>comp_id</dt><dd>Column(String(length=40)), id of the computing component the job is running on currently</dd>
    <dt>explicit_wait</dt><dd>Column(DateTime), timestamp of the moment when computing component told job to wait in queue because no slots were free</dd>
    <dt>dequeued</dt><dd>Column(DateTime), timestamp when this job was in waiting state and was last time dequeued. See job <a href="#queueing">queueing</a>.</dd>
</dl>

<h3>Job State</h3>
<a name="states">
<img src="img/task_states.png" alt="Job Manager task states, img/task_states.dot for textual representation"/>
</a>

<h3>Job Queueing</h3>
<a name="queueing"></a>
If a received job is acked by a computing component telling the it is currently busy the job will be queued. This way the job will not timeout, and the job resubmission will be tried once 
<ul>
<li>the job timer triggers: JobManager uses internal polling loop which goes through all active jobs (i.e. jobs which are not cancelled, completed, failed, or errored) and checks
    if job resubmission should be tried.
<li>When a running job completes, JobManager dequeues another job to execution. This prevents the need to wait for timer to trigger. Dequeued job might not be to proceed to execution in case the tool it requires is not available on the available host.
Dequeued field of the job is updated everytime a job is queued, and the job with latest dequeued timestamp is dequeued.</li>
</ul>

<h2>Tests</h2>
<p>Run tests (requires tox)
    <code>tox .</code></p>

<p>Run coverage for tests (requires nose, pytest, coverage)
    <code>nosetests --cover-package=jobmanager --with-coverage</code></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/CSC-IT-Center-for-Science">CSC-IT-Center-for-Science</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
